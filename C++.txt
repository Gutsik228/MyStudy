Переменные
Типы данных
{
	int, float, double, short, long, string, bool, Uint, Ulong, char 
}
Условные конструкции
{
	if - else, else if, тернарный оператор - int c = a > b? (a : b); 
} 
Циклы
{
	for, while, do while, try catch, for(auto c : s)
}
Контейнеры
{
	Вектор, массив, двумерный вектор(массив), множество, хеш таблица, односвязный список
}
ОПП
{
	Наследование, инкапсуляция, полиморфизм
}



()Функция inline - помогает быстрее выполнять функции. Только небольшие и простые функции типо сложения, вычитания и тд
inline ставится перед вызовом функции 
inline void DoSome();

()Перегрузка функций - использование разных функций с одиннаковым(иногда разным) блоком кода и названием, но с разными переменными и разным количеством переменных
void printNumber(int num)
{
    cout << "Это int: " << num << endl;
}

void printNumber(double num)
{
    cout << "Это double: " << num << endl;
}

void printNumber(std::string str)
{
    cout << "Это строка: " << str << endl;
}





()Шаблонная функция - функция , которая может использовать различные типы данных, с перегрузками
Такая функция работает только с одним типом данных
template <typename T>
T Sum(T a, T b){};
Такая функция принимает различные значения
template <typename T1, typename T2>
T1 Sum(T1 a, T2 b){};





()Рекурсия, функция и стек



()Динамическая стуктура данных (контейнер)
Односвязный список - это структура данных, которая состоит из узлов, где каждый узел содержит значение данных и ссылку на следующий узел в списке. Последний узел списка ссылается на NULL или нулевой указатель.



()Указатели, ссылки
int a = 5;
int *pa = &a;
* - указатель(утератор) учавствует в указании области памяти
& - предоставляет ссылку для области памяти переменной 
cout << pa; - выведет ссылку на облась памяти
cout << *pa; - выведет значение по ссылку

Указатели и ссылки в массивах
Массив - это ссылочный тип данных поэтому для него по другому работают указатели
int arr[]
int *Arr = arr; - не нужно использовать & для передачи ссыллки, потому что массив - Сыл. тип данных
Название массива это ссылка на его первый элемент
данные в массиве хранятся последовательно
Каждая ячейка памяти в массиве имеет свое расстояние, в типе инт это 4 байта - один символ, то есть, если добавить 1 или 2 к переменной массива и разархивироавать , то выведется число по индексу 1 или 2, 

()new - выделяет память для переменных или динамиеческих систем, нужно обязательно использовать delete для того чтобы очистить память


()Двумерный динамический массив 
int rows = 5;
int cols = 6;
int **arr(указатель на указатель) = new int*[rows];

delete [] arr; 


VECTOR
1. `push_back`:
   - Метод `push_back` добавляет элемент в конец вектора.
   - Пример:
     ```cpp
     std::vector<int> vec;
     vec.push_back(10);
     vec.push_back(20);
     vec.push_back(30);
     ```
     В результате вектор будет содержать элементы `[10, 20, 30]`.

2. `size`:
   - Метод `size` возвращает текущий размер вектора (количество элементов).
   - Пример:
     ```cpp
     std::vector<int> vec = {10, 20, 30};
     std::cout << vec.size(); // Выводит 3
     ```

3. `operator[]`:
   - Оператор `[]` позволяет обращаться к элементам вектора по индексу.
   - Пример:
     ```cpp
     std::vector<int> vec = {10, 20, 30};
     std::cout << vec[1]; // Выводит 20
     ```

4. `pop_back`:
   - Метод `pop_back` удаляет последний элемент из вектора.
   - Пример:
     ```cpp
     std::vector<int> vec = {10, 20, 30};
     vec.pop_back();
     ```
     В результате вектор будет содержать элементы `[10, 20]`.

5. `clear`:
   - Метод `clear` удаляет все элементы из вектора, делая его пустым.
   - Пример:
     ```cpp
     std::vector<int> vec = {10, 20, 30};
     vec.clear();
     ```

6. `empty`:
   - Метод `empty` проверяет, является ли вектор пустым.
   - Пример:
     ```cpp
     std::vector<int> vec;
     std::cout << vec.empty(); // Выводит 1 (true)
     ```

7. `resize`:
   - Метод `resize` изменяет размер вектора.
   - Пример:
     ```cpp
     std::vector<int> vec = {10, 20, 30};
     vec.resize(5);
     ```
     В результате вектор будет содержать элементы `[10, 20, 30, 0, 0]`.

8. `insert`:
   - Метод `insert` вставляет элементы в указанную позицию вектора.
   - Пример:
     ```cpp
     std::vector<int> vec = {10, 20, 30};
     vec.insert(vec.begin() + 1, 15);
     ```
     В результате вектор будет содержать элементы `[10, 15, 20, 30]`.
если использовать несколько аргументов в insert то - vector.insert(vector.end(), vector[i], vector[i + 1]) -
в vector добавится vector[i] элементов vector[i+1]
	

9. `erase`:
   - Метод `erase` удаляет элементы из вектора по указанной позиции или диапазону.
   - Пример:
     ```cpp
     std::vector<int> vec = {10, 20, 30};
     vec.erase(vec.begin() + 1);
     ```
     В результате вектор будет содержать элементы `[10, 30]`.

10. `reserve`:
    - Метод `reserve` выделяет память для указанного количества элементов вектора.
    - Пример:
      ```cpp
      std::vector<int> vec;
      vec.reserve(100);
      ```
      Вектор будет иметь зарезервированную память для 100 элементов, но фактический размер вектора останется нулевым.

11. `swap`:
    - Метод `swap` обменивает содержимое двух векторов.
    - Пример:
      ```cpp
      std::vector<int> vec1 = {10, 20, 30};
      std::vector<int> vec2 = {40, 50};
      vec1.swap(vec2);
      ```
      В результате `vec1` будет содержать элементы `[40, 50]`, а `vec2` будет содержать элементы `[10, 20, 30]`.

12. `emplace_back`: 
    - Метод `emplace_back` добавляет элемент в конец вектора, конструируя его на месте.
    - Пример:
      ```cpp
      struct Point {
          int x;
          int y;
      };
      
      std::vector<Point> vec;
      vec.emplace_back(10, 20);
      ```
      В результате вектор будет содержать элемент `{10, 20}`
13. sort - sort(nums.begin(), nums.end());

