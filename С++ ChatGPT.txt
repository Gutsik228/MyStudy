Переменные:
Типы данных:
- int: целочисленный тип данных, используется для хранения целых чисел.
Пример: int num = 10;

- float: тип данных с плавающей запятой, используется для хранения чисел с плавающей запятой одинарной точности.
Пример: float pi = 3.14;

- double: тип данных с плавающей запятой, используется для хранения чисел с плавающей запятой двойной точности.
Пример: double distance = 2.5;

- short: целочисленный тип данных, используется для хранения целых чисел в более коротком диапазоне значений.
Пример: short count = 100;

- long: целочисленный тип данных, используется для хранения целых чисел в более длинном диапазоне значений.
Пример: long population = 1000000;

- string: тип данных для хранения текстовых строк.
Пример: string name = "John";

- bool: логический тип данных, используется для хранения значения истины или лжи.
Пример: bool isTrue = true;

- Uint: беззнаковый целочисленный тип данных, используется для хранения положительных целых чисел.
Пример: Uint positiveNum = 50;

- Ulong: беззнаковый целочисленный тип данных, используется для хранения положительных целых чисел в более длинном диапазоне значений.
Пример: Ulong largeNum = 1000000000;

- char: тип данных для хранения одного символа.
Пример: char letter = 'A';

Условные конструкции:
- if-else: используется для выполнения блока кода, если условие истинно, и выполнения другого блока кода, если условие ложно.
Пример:
```cpp
if (x > 0) {
    cout << "Positive";
} else {
    cout << "Negative";
}

- else if: используется для проверки нескольких условий, когда первое условие ложно.
Пример:
```cpp
if (x > 0) {
    cout << "Positive";
} else if (x < 0) {
    cout << "Negative";
} else {
    cout << "Zero";
}

- тернарный оператор: используется для сокращения кода при присваивании значения в зависимости от условия.
Пример:
```cpp
int c = (a > b) ? a : b;

Циклы:
- for: используется для выполнения блока кода определенное количество раз.
Пример:
```cpp
for (int i = 0; i < 10; i++) {
    cout << i << endl;
}

- while: используется для выполнения блока кода до тех пор, пока условие истинно.
Пример:
```cpp
int i = 0;
while (i < 10) {
    cout << i << endl;
    i++;
}

- do while: используется для выполнения блока кода хотя бы один раз, а затем проверяет условие для продолжения выполнения.
Пример:
```cpp
int i = 0;
do {
    cout << i << endl;
    i++;
} while (i < 10);

- try catch: используется для обработки исключений в блоке кода.
Пример:
```cpp
try {
    // код, который может вызвать исключение
} catch (exception e) {
    // обработка исключения
}

- for(auto c : s): используется для выполнения цикла для каждого элемента в контейнере.
Пример:
```cpp
string s = "Hello";
for (auto c : s) {
    cout << c << endl;
}

Контейнеры:
- Вектор: динамический массив, который может изменять свой размер.
Пример: vector<int> numbers = {1, 2, 3};

- Массив: статический контейнер, который хранит фиксированное количество элементов одного типа.
Пример: int arr[5] = {1, 2, 3, 4, 5};

- Двумерный вектор (массив): контейнер, который представляет собой вектор векторов и используется для хранения двумерных данных.
Пример: vector<vector<int>> grid = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};

- Множество: контейнер, который хранит уникальные элементы в отсортированном порядке.
Пример: set<int> numbers = {1, 2, 3, 4, 5};

- Хеш-таблица: контейнер, который использует хеш-функцию для хранения и доступа к элементам.
Пример: unordered_map<string, int> ages = {{"John", 25}, {"Emily", 30}, {"Michael", 35}};

- Односвязный список: структура данных, состоящая из узлов, где каждый узел содержит значение данных и ссылку на следующий узел в списке. Последний узел списка ссылается на NULL или нулевой указатель.
Пример: 
```cpp
struct Node {
    int data;
    Node* next;
};

Node* head = nullptr;
head = new Node;
head->data = 1;
head->next = nullptr;

ООП:
- Наследование: механизм, который позволяет создавать новый класс на основе существующего класса, наследуя его свойства и методы.
Пример:
```cpp
class Animal {
public:
    void eat() {
        cout << "Animal is eating" << endl;
    }
};

class Dog : public Animal {
public:
    void bark() {
        cout << "Dog is barking" << endl;
    }
};

- Инкапсуляция: механизм, который объединяет данные и методы внутри класса и скрывает их от внешнего мира.
Пример:
```cpp
class Person {
private:
    string name;
    int age;
public:
    void setName(string n) {
        name = n;
    }
    void setAge(int a) {
        age = a;
    }
    string getName() {
        return name;
    }
    int getAge() {
        return age;
    }
};

- Полиморфизм: возможность объектов разных классов иметь разные формы, но общий интерфейс.
Пример:
```cpp
class Shape {
public:
    virtual void draw() {
        cout << "Drawing a shape" << endl;
    }
};

class Circle : public Shape {
public:
    void draw() {
        cout << "Drawing a circle" << endl;
    }
};

class Square : public Shape {
public:
    void draw() {
        cout << "Drawing a square" << endl;
    }
};

Функция inline: помогает ускорить выполнение функций, особенно для небольших и простых функций, таких как сложение или вычитание.
Пример:
```cpp
inline int add(int a, int b) {
    return a + b;
}

Перегрузка функций: возможность использовать несколько функций с одинаковым (или иногда разным) блоком кода и названием, но с разными переменными и разным количеством переменных.
Пример:
```cpp
void printNumber(int num) {
    cout << "Это int: " << num << endl;
}

void printNumber(double num) {
    cout << "Это double: " << num << endl;
}

void printNumber(string str) {
    cout << "Это строка: " << str << endl;
}

Шаблонная функция: функция, которая может использовать различные типы данных, с возможностью перегрузки.
Пример:
```cpp
template <typename T>
T sum(T a, T b) {
    return a + b;
}

template <typename T1, typename T2>
T1 sum(T1 a, T2 b) {
    return a + b;
}

- Исключения: механизм, который позволяет обрабатывать ошибки и неожиданные ситуации в программе.
Пример:
```cpp
try {
    // код, который может вызвать исключение
    if (x == 0) {
        throw "Division by zero";
    }
    int result = y / x;
} catch (const char* error) {
    // обработка исключения
    cout << "Error: " << error << endl;
}

- Рекурсия: процесс, в котором функция вызывает саму себя.
Пример:
```cpp
int factorial(int n) {
    if (n == 0) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}

int result = factorial(5); // результат: 5 * 4 * 3 * 2 * 1 = 120

Динамическая структура данных (контейнер):
Динамическая структура данных - это структура данных, которая позволяет изменять свой размер во время выполнения программы. В отличие от статической структуры данных, которая имеет фиксированный размер, динамическая структура данных может быть увеличена или уменьшена в зависимости от требований программы.

Односвязный список:
Односвязный список - это структура данных, состоящая из узлов, где каждый узел содержит значение данных и ссылку на следующий узел в списке. Последний узел списка ссылается на NULL или нулевой указатель. Односвязный список позволяет эффективно добавлять и удалять элементы в начале, конце или середине списка.

Указатели и ссылки:
Указатели и ссылки - это инструменты языка C++, которые позволяют работать с адресами памяти переменных. Указатель - это переменная, которая содержит адрес памяти другой переменной. Ссылка - это псевдоним для переменной, которая ссылается на ту же область памяти. Указатели и ссылки позволяют передавать и обрабатывать адреса памяти переменных, что может быть полезно для эффективной работы с данными.

Указатели и ссылки в массивах:
Указатели и ссылки в массивах позволяют обращаться к элементам массива по их индексам. Название массива является указателем на его первый элемент, поэтому для обращения к элементам массива можно использовать указатель или ссылку. Указатели и ссылки позволяют эффективно обрабатывать и изменять данные в массиве.

Оператор new:
Оператор new используется для выделения динамической памяти во время выполнения программы. Он возвращает указатель на выделенную область памяти, которую можно использовать для хранения данных. После использования выделенной памяти необходимо освободить с помощью оператора delete, чтобы избежать утечек памяти.

Двумерный динамический массив:
Двумерный динамический массив - это массив, который может изменять свой размер по горизонтали и вертикали во время выполнения программы. Для создания двумерного динамического массива необходимо использовать указатель на указатель, который будет указывать на массив указателей на строки. Каждая строка представляет собой массив элементов. После использования двумерного динамического массива необходимо освободить память с помощью оператора delete.

Линейный поиск:
Линейный поиск - это алгоритм поиска элемента в массиве или списке путем последовательного сравнения каждого элемента с целевым значением. Если элемент найден, возвращается его индекс, в противном случае возвращается значение, указывающее на отсутствие элемента.

Бинарный поиск:
Бинарный поиск - это алгоритм поиска элемента в отсортированном массиве или списке путем последовательного деления массива на половины и сравнения целевого значения с серединой каждой половины. Если элемент найден, возвращается его индекс, в противном случае возвращается значение, указывающее на отсутствие элемента.